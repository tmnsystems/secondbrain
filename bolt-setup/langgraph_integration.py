"""
LangGraph integration with Bolt.diy for SecondBrain project.
This script sets up the LangGraph agents that will interact with Bolt.
"""

import os
import json
import requests
from typing import Dict, List, Any, Optional
from pydantic import BaseModel, Field
import langgraph.graph as lg
from langgraph.prebuilt import ToolNode
from langgraph.graph import StateGraph

# Define the base URL for the Bolt API Bridge
BOLT_API_URL = "http://localhost:3030/api"

# Models for our agent states
class AgentState(BaseModel):
    """State for the agent workflow"""
    query: str = Field(description="The user's query or request")
    context: Optional[Dict[str, Any]] = Field(default=None, description="Context information")
    steps: List[str] = Field(default_factory=list, description="Steps taken in the workflow")
    output: Optional[str] = Field(default=None, description="Output generated by the workflow")

# Tool functions for interacting with Bolt
def generate_code_with_bolt(prompt: str) -> str:
    """Generate code using Bolt.diy through the API bridge"""
    try:
        response = requests.post(
            f"{BOLT_API_URL}/generate-code",
            json={"prompt": prompt},
            timeout=30
        )
        response.raise_for_status()
        return response.json().get("code", "Error: No code generated")
    except Exception as e:
        return f"Error generating code: {str(e)}"

# LangGraph nodes
def query_understanding(state: AgentState) -> AgentState:
    """Understand the user query and determine the next steps"""
    query = state.query
    steps = state.steps.copy()
    steps.append("Analyzed query: " + query)
    
    # In a real implementation, this would use an LLM to understand the query
    # For now, we'll use simple keyword matching
    if "code" in query.lower() or "generate" in query.lower():
        steps.append("Determined this is a code generation request")
        return AgentState(
            query=query,
            steps=steps,
            context={"is_code_request": True}
        )
    else:
        steps.append("Determined this is a general request")
        return AgentState(
            query=query,
            steps=steps,
            context={"is_code_request": False}
        )

def code_generation(state: AgentState) -> AgentState:
    """Generate code using Bolt.diy"""
    query = state.query
    steps = state.steps.copy()
    steps.append("Generating code with Bolt.diy")
    
    # Call Bolt.diy API bridge to generate code
    code = generate_code_with_bolt(query)
    
    steps.append("Code generated successfully")
    return AgentState(
        query=query,
        steps=steps,
        context=state.context,
        output=code
    )

def general_response(state: AgentState) -> AgentState:
    """Generate a general response for non-code requests"""
    query = state.query
    steps = state.steps.copy()
    steps.append("Generating general response")
    
    # In a real implementation, this would use an LLM to generate a response
    response = f"I understand you're asking about: {query}. How can I help you with this?"
    
    steps.append("General response generated")
    return AgentState(
        query=query,
        steps=steps,
        context=state.context,
        output=response
    )

def router(state: AgentState) -> str:
    """Route to the appropriate node based on the query context"""
    if state.context and state.context.get("is_code_request", False):
        return "code_generation"
    else:
        return "general_response"

# Build the LangGraph workflow
def build_workflow() -> StateGraph:
    """Build the main workflow graph"""
    workflow = StateGraph(AgentState)
    
    # Add nodes
    workflow.add_node("query_understanding", query_understanding)
    workflow.add_node("code_generation", code_generation)
    workflow.add_node("general_response", general_response)
    
    # Add edges
    workflow.add_edge("query_understanding", router)
    workflow.add_edge("code_generation", "END")
    workflow.add_edge("general_response", "END")
    
    # Set entry point
    workflow.set_entry_point("query_understanding")
    
    return workflow

# Create a compiled version of the workflow
workflow = build_workflow().compile()

def process_request(query: str) -> Dict[str, Any]:
    """Process a user request through the workflow"""
    initial_state = AgentState(query=query)
    result = workflow.invoke(initial_state)
    
    return {
        "query": result.query,
        "steps": result.steps,
        "output": result.output,
    }

if __name__ == "__main__":
    # Example usage
    example_query = "Generate a React component for a user profile page"
    result = process_request(example_query)
    print(json.dumps(result, indent=2))